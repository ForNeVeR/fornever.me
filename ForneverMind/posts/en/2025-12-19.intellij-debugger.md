    title: Implementing debugger for IntelliJ Platform
    description: This describes implementing a sample debugger based on XDebugger API of IntelliJ Platform.
---
IntelliJ platform allows the plugins to implement debuggers for various technologies. In this post, we will explore how to implement a debugger for AutoHotKey (via DBGP common debugging protocol) using the XDebugger API of IntelliJ Platform.

For this tutorial, I was looking for something that isn't yet available in IntelliJ, while having a reasonable level of complexity to demonstrate the debugging API. So I chose the DBGP protocol (the one originally invented by PHP but later used by some other parties), and in particular ‚Äî ability to debug [AutoHotKey][autohotkey] programs using it. As it turns out, AutoHotKey supports debugging via DBGP for a long time already; here's [the list][autohotkey.debuggers] of compatible debuggers that understand the protocol and support AutoHotKey.

So, in this post I'll explain some core concepts that are required for understanding how debuggers work in IntelliJ, then explain my approach to DBGP, and then show some examples of the code in the debugger. All the sources are available in a separate repository: [intellij-autohotkey-debugger-sample][repository].

To start a new plugin, use the IntelliJ Platform Plugin Template repository: [intellij-platform-plugin-template][intellij-platform-plugin-template].

## Core Concepts

### Run Configuration
The first, obvious entry point for the user to debug a program in IntelliJ is a corresponding [run configuration][intellij.run-configurations]: the user clicks the **üêû Debug** button on the main toolbar, and the debugger gets started.

The run configuration subsystem in IntelliJ is a bit complex and has a lot of moving parts; it's worth reading the [documentation][plugins.run-configurations] to understand the basics. Nevertheless, below I'll explain how to create a bare minimum configuration with run and debug support for AutoHotKey.

#### Run Mode
First of all, let's make sure the user is able to _run_ the program ‚Äî not _debug_ yet.

To do this, we'll need to implement and register several things, mostly boilerplate.
1. An implementation of the `ConfigurationType` interface, also registered in the `plugin.xml`:

   ```kotlin
   class AutoHotKeyRunConfigurationType : ConfigurationTypeBase(‚Ä¶) {
       // ‚Ä¶
   }
   ```

   Registering this type will allow the user to create a run configuration manually in the run configuration dialog.
2. An implementation of the `RunConfiguration` interface that will be produced by the factory:

   ```kotlin
   class AutoHotKeyRunConfiguration(‚Ä¶) : LocatableConfigurationBase<Element>(‚Ä¶) {

       var filePath: Path? = null

       override fun getState(
           executor: Executor,
           environment: ExecutionEnvironment
       ): RunProfileState = AutoHotKeyRunProfileState(
           environment,
           filePath ?: throw CantRunException("File path is not set.")
       )
       // ‚Ä¶
   }
   ```
3. A factory class that will be producing the configuration (mostly used by the `ConfigurationType` implementation):

   ```kotlin
   class AutoHotKeyRunConfigurationFactory(‚Ä¶) : ConfigurationFactory(‚Ä¶)
   ```
4. An implementation of the `RunProfileState` interface that contains the code that actually runs the process in the PTY mode (this mode isn't important for AutoHotKey, but it's a good practice to use it for other languages):

   ```kotlin
   class AutoHotKeyRunProfileState(
       environment: ExecutionEnvironment,
       private val filePath: Path
   ) : CommandLineState(environment) {
       // ‚Ä¶

       private fun startProcess(arguments: List<String>): ProcessHandler {
            val interpreter = findAutoHotKeyInterpreter()
                ?: throw CantRunException(DebuggerBundle.message("run-configuration.error.interpreter-not-found"))
            val commandLine = PtyCommandLine()
                .withConsoleMode(false)
                .withWorkingDirectory(filePath.parent)
                .withExePath(interpreter.pathString)
                .withParameters(arguments + filePath.pathString)

            return object : KillableColoredProcessHandler(commandLine) {
                override fun shouldKillProcessSoftly() = false
            }
        }

        override fun startProcess(): ProcessHandler =
            startProcess(emptyList())
   }
   ```

   Here, `private fun startProcess` is extracted only for the future use when we start implementing the debugger: it will use the same function, but add some arguments.

   One notable fact here is that we override the `shouldKillProcessSoftly` function for our implementation of the `ProcessHandler`: this is necessary because AutoHotKey doesn't track the graceful termination attempts when run in PTY mode, so there's no sense in trying to terminate it gracefully. This isn't necessarily true for any other debuggers and run configurations, though ‚Äî you can provide your own graceful termination routines if necessary.
5. For the user's convenience, to be able to use the **Run Current File** function, and run `.ahk` files from the context menu, implement and register an implementation of the `RunConfigurationProducer` interface:

   ```kotlin
   class AutoHotKeyRunConfigurationProducer : LazyRunConfigurationProducer<AutoHotKeyRunConfiguration>() {
       // ‚Ä¶
   }
   ```

#### Debug Mode
TODO!

## Implementation Notes
### Breakpoints
The first thing we need is to allow the user to put the breakpoints into `.lua` files; by default, IDE will not allow this, as the files are recognized as the plain-text ones (even though they are augmented by the TextMate highlighting).

So, let's start by creating a class inheriting the `XLineBreakpointType`:
```kotlin
class LuaBreakpointType : XLineBreakpointType<XBreakpointProperties<*>>("lua", DebuggerBundle.message("lua.breakpoint.type.display.name")) {

    override fun canPutAt(
        file: VirtualFile,
        line: Int,
        project: Project
    ): Boolean {
        return file.extension == "lua"
    }

    override fun createBreakpointProperties(
        file: VirtualFile,
        line: Int
    ): XBreakpointProperties<*>? = null
}
```

Here, the most important part is the `canPutAt` method, which checks if the file extension is `lua`. In other languages, you might decide to check for file's language (since the user might mark other files as belonging to the language), but for this simple example check for file extension will be enough.

[autohotkey.debuggers]: https://www.autohotkey.com/docs/v2/AHKL_DBGPClients.htm
[autohotkey]: https://www.autohotkey.com/
[intellij-platform-plugin-template]: https://github.com/JetBrains/intellij-platform-plugin-template
[intellij.run-configurations]: https://www.jetbrains.com/help/idea/run-debug-configuration.html
[plugins.run-configurations]: https://plugins.jetbrains.com/docs/intellij/run-configurations.html
[repository]: https://github.com/ForNeVeR/intellij-autohotkey-debugger-sample
